**定义** 
代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
- 静态代理</br>
优点，在做到符合开闭原则的情况下，对目标对象进行扩展。</br>
缺点，每个服务都得创建代理，接口改变，代理类也得变。
- 动态代理</br>
- 编辑动态处理器。
- jdk动态创建
> jdk代理解决了静态代理需要为每个业务接口创建一个代理类的问题。
缺点：其需要被代理的对象必须实现一个接口
- cglib创建 
> Cglib代理的原理是动态生成被代理类的子类字节码
>> 根据Cglib实现原理，由于其是通过创建子类字节码的形式来实现代理的，如果被代理类的方法被声明final类型，那么Cglib代理是无法正常工作的，因为final类型方法不能被重写
### 涉及角色
代理模式包含如下三个角色：

- Subject（抽象主题角色）：
> 它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。

- Proxy（代理主题角色）：
> 它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。

- RealSubject（真实主题角色）：
> 它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。
